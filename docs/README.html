<!DOCTYPE html>

<html>
<head>
  <title>README</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="https://strd6.github.io/cdn/parallel/docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    <ul class="sections">
      <li id="section-1">
  <div class="annotation">
    <div class="pilwrap">
      <a class="pilcrow" href="#section-1">&#182;</a>
    </div>
    <h1 id="honegar">honegar</h1>
<p>A sweet sweet honeypot of a game.</p>
<p>In scope comprable to Dwarf Fortress but with a few differences in philosophy.</p>
<p>This game will be open and accessible. Web based, playable in the browser. It
will be collaborative. We&#39;ll explore many of the same themes: society building,
emergent behavior from complex systems, fantasy and rpg elements, autonamous
agents, procedural generation.</p>
<h2 id="features">Features</h2>
<p>Birth and death</p>
<p>Lineage and family trees</p>
<p>Cultural evolution</p>
<p>History and legends</p>
<p>Procedurally generated songs and music that you can hear, rendered in MIDI.</p>
<p>Natural and synthetic drugs, hallucinogens, alcohol.</p>
<p>Drunk Driving</p>
<p>Procedurally generated books</p>
<p>Basic perceptual modelling of autonamous agents.</p>
<p>Roles like surveyor and planner can designate work for others.</p>
<p>Laws, legal system, jurisdictions, detection and enforcibility of crimes.</p>
<p>Emergent economics: asset bubbles and crashes.</p>
<p>Water, magma, oil</p>
<p>Collectivist and individualist societies</p>
<p>Evolutionary selection of laws, social customs, prejudices.</p>
<p>Mental illness, depression bi-polar disorder.</p>
<p>Disease and medicine.</p>
<p>Procedurally generated sex acts.</p>
<p>War, famine, capitalism, class struggle</p>
<p>Religious texts encouraging and prohibiting certain actions (expect to see an 
emergence of memetics and proselytizing)</p>
<p>Ecosystems, plants, fungus, trees, animals.</p>
<p>Property ownership, rent seeking.</p>
<p>Debt backed securites.</p>
<p>Collaborative networked play</p>
<p>Plugins and user generated subsystems.</p>
<h2 id="scenarios">Scenarios</h2>
<p>A goblin is put to death for violating an emergent law by telling a procedurally
generated joke.</p>
<p>Spring rains and favorable weather cause an immense bloom of flowers, causing a
boom and then bust in the bee population.</p>
<p>Rowdy elf teens get high off of cave fungus.</p>
<p>Alcohol is prohibited and the local sheriff comissions a posse to destroy all
the stills.</p>
<p>A famine causes waves of migrant gnomes to spread forth throughout the land
sharing their culture and over hundreds of years assimilating into different
societies to varying degrees. Some are always treated as second class citizens
while others arriving among more tolerant cultures are equals and can own land
and property.</p>
<h2 id="overview">Overview</h2>
<p>This is vast in scope, but the goal will be to find the simplest systems that
can be composed together to create vibrant emergent behavior.</p>
<p>Hopefully will be a never ending source of fun work!</p>

  </div>
  <div class="content"><pre><code>
</code></pre>
</div>
</li>
    </ul>
  </div>
  <script src="https://code.jquery.com/jquery-1.10.1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/coffee-script/1.6.3/coffee-script.min.js"></script><script>
  (function() {
  var ErrorReporter, bindUpdates, createEditor, exec, findInteractiveElements, readShebang, runners;

  createEditor = function(code, shebang, section) {
    var annotationElement, contentElement, editorElement, exampleSection, runtimeElement;
    exampleSection = $("<li>", {
      "class": "example"
    });
    annotationElement = $("<div>", {
      "class": "annotation"
    });
    editorElement = $("<textarea>", {
      "class": "annotation",
      text: code
    });
    contentElement = $("<div>", {
      "class": "content"
    });
    runtimeElement = $("<div>", {
      "class": "output"
    });
    contentElement.append(runtimeElement);
    annotationElement.append(editorElement);
    exampleSection.append(annotationElement);
    exampleSection.append(contentElement);
    section.after(exampleSection);
    return bindUpdates(shebang, editorElement, runtimeElement);
  };

  bindUpdates = function(shebang, editorElement, runtimeElement) {
    return editorElement.on("keyup", function() {
      var e, report, source;
      report = ErrorReporter(editorElement);
      source = editorElement.val();
      try {
        runners[shebang]({
          editorElement: editorElement,
          source: source,
          runtimeElement: runtimeElement
        });
        return report.clear();
      } catch (_error) {
        e = _error;
        return report(e);
      }
    });
  };

  readShebang = function(source) {
    var match;
    if (match = source.match(/^\#\! (.*)\n/)) {
      return match[1];
    }
  };

  ErrorReporter = function(editor) {
    var reporter;
    reporter = function(error) {
      var errorParagraph;
      if (editor.next().is("p.error")) {
        return editor.next().text(error);
      } else {
        errorParagraph = $("<p>", {
          "class": "error",
          text: error.toString()
        });
        return editor.after(errorParagraph);
      }
    };
    reporter.clear = function() {
      if (editor.next().is("p.error")) {
        return editor.next().remove();
      }
    };
    return reporter;
  };

  findInteractiveElements = function() {
    return $("blockquote > pre > code").each(function() {
      var blockQuoteElement, code, codeElement, sectionElement, shebang;
      codeElement = $(this);
      code = codeElement.text();
      if (shebang = readShebang(code)) {
        if (!runners[shebang]) {
          return;
        }
        code = code.split("\n").slice(1).join("\n");
        blockQuoteElement = codeElement.parent().parent();
        sectionElement = blockQuoteElement.parent().parent();
        blockQuoteElement.remove();
        return createEditor(code, shebang, sectionElement);
      }
    });
  };

  runners = {};

  (typeof window !== "undefined" && window !== null ? window : global).Interactive = {
    register: function(name, runner) {
      runners[name] = runner;
      findInteractiveElements();
      return $('#container').on('keyup', 'textarea', function() {
        $(this).height(0);
        return $(this).height(this.scrollHeight);
      }).find('textarea').keyup();
    }
  };

  exec = function(_arg) {
    var code, editorElement, runtimeElement, source;
    source = _arg.source, code = _arg.code, editorElement = _arg.editorElement, runtimeElement = _arg.runtimeElement;
    runtimeElement.remove();
    editorElement.replaceWith($("<pre>", {
      text: source
    }));
    return setTimeout(function() {
      return Function(code)();
    }, 0);
  };

  $(function() {
    Interactive.register("setup", function(params) {
      params.code = CoffeeScript.compile(params.source);
      return exec(params);
    });
    return Interactive.register("setup-js", function(params) {
      params.code = params.source;
      return exec(params);
    });
  });

}).call(this);

</script><script src="package.js"></script>
</body>
</html>